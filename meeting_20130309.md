## Kuon ##

> 靜態分析
> 用 clang 當分析工具
> Lex
> -> token 的處理要考慮到 encoding
> Parse
> -> 容錯的處理
> -> 動態語言: lazy parsing
-> 以 PHP 為例: 考慮到屬性與 runtime 的行為
商業產品的要求
PHP 一開始僅處理 template，但後期得考慮跨越程式語言的條件 (Web)
PHP/HTML/JavaScript context
得引入中間語言再進行分析
-> 先設計一個通用的程式語言 (downgrade)，再來分析
AST
-> 要編譯的話，就要作語意分析 (type, class
-> 包含最多的資訊，每次處理，就會犧牲資訊
-> 通常低階的表示式無法包含足夠的資訊，也無法回推

Open64 有 5 種 IR
Clang 有 5 個階段的分析，是 compiler frontend framework
以 #include 的操作為例，基本上就是展開到原始碼中，但為何編譯器可以回報特定的行號有錯誤呢？因為展開的過程中，連同原始的行號資訊都被含入了
改寫(rewrite), backend transform
常數展開來說，可在前端也可在後端作，若在前端，則每個程式語言都得作
clang 可與 IDE 整合，如 code complete
不全然都是 AST，用到 cache 的技巧，才能分析未寫完的程式碼
indexer

商業軟體的分析，以 PHP + SQL 為例:
SQL -> parse to command language
stored procedure 轉換成內部的函式表示

C++ 有四種 casting，這些都由 programmer 決定，行為影響到 runtime object layout
所以該如何分析？

information flow

CFG (control flow graph)
在低階的概念，就是 branch
但在高階語言，就是一系列的表示
抽象化處理
AST -> Tree, Node
flow-sensitive, flow-insensitive (->不準，但覆蓋率高，少了很多約束)
在 Web 中，entry-point 的概念被模糊化了
每個 PHP 程式放在 Web 中，其實都有機會被執行到 -> 都可能是 entry-point
以 MVC framework 來說，會在 controller 進入
PHP 的模組可動態載入，並非語法定義，而是依據動態特性
basic block

data flow graph
-> C/C++ 的難處在於 aliasing (pointer, reference)
-> 沒有唯一解
-> alias analysis (LLVM)
-> array 是容器，可進行擴充 (collection)，對於有問題的使用者輸入，如何在靜態分析中，如何得知特定元素被污染
以 boundary check 為例，仍有力道的問題
coverity static analysis tool
數學上可歸納為格論

call graph -> 函式與函式之間的呼叫
IPA: inter-procedure, infra-procedure
LTO: Link-time optimization, 對 whole program 分析
儲存空間的議題
domain knowledge 可縮減表達的複雜度，進行加速
-> 比方說分析 SQL injection，但已知只與資料庫處理有關，於是可去除無關的部份

動態分析的層級
static, dynamic, runtime

pin from Intel
-> 動態改變動態程式碼
從系統界面的角度
從程式碼的角度
valgrind: 仍有 IR 的處理，先進行指令集的分析，再來作 memory 一類的檢查
常見的安全問題: use-after-free, 可抽象為 path 的問題，在一個 path 上是否有 double free

PHP Encoder
Zend bytecode 在不同版本，都有不同的表現與 opcode 意義上的變異

.Net CIL
如果只分析 IL，那麼 template 層級則無法分析

## Terry ##
http://www.ee.nsysu.edu.tw/led2012/defaultm.asp
拿紅外線作穿透，而非照明
概念來自紅外線作心搏的測量
紅外線光電晶體 / phototransistor
排除陣列排法，改用類似掃描線的處理
找到最小的直徑 3mm
可檢測每個人的骨質密度